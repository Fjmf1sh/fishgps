<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI GPS Assistant with Route Details in Miles</title>
  <!-- Load Leaflet CSS without integrity attributes -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" crossorigin=""/>
  <style>
    html, body { margin: 0; padding: 0; height: 100vh; }
    #map { height: 60vh; width: 100%; }
    #assistant { height: 40vh; overflow-y: auto; background: #111; color: #0f0; padding: 10px; }
    #inputArea {
      display: flex; 
      flex-direction: column;
      gap: 5px;
      padding: 10px;
    }
    #userInput { width: 100%; padding: 10px; box-sizing: border-box; }
    #globalToggle { margin-top: 5px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="assistant">
    <div id="messages"><strong>AI Assistant:</strong> Type a destination</div>
    <div id="inputArea">
      <input type="text" id="userInput" placeholder="e.g., Starbucks, gas station" />
      <label id="globalToggle">
        <input type="checkbox" id="globalSearch" /> Global Search
      </label>
    </div>
  </div>
  
  <!-- Load Leaflet JS without integrity attributes -->
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" crossorigin=""></script>
  <script>
    let map, userMarker, routeLayer;
    let userCoords = null;

    // Initialize the map and update user's marker continuously
    function initMap(lat, lon) {
      map = L.map('map').setView([lat, lon], 14);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);
      userMarker = L.marker([lat, lon]).addTo(map).bindPopup("You are here").openPopup();
      navigator.geolocation.watchPosition(
        pos => {
          const { latitude, longitude } = pos.coords;
          userCoords = [latitude, longitude];
          userMarker.setLatLng(userCoords);
          map.setView(userCoords);
        },
        err => { console.error(err); }
      );
    }
    
    // Get the initial GPS location (or use default if not allowed)
    navigator.geolocation.getCurrentPosition(
      position => {
        const { latitude, longitude } = position.coords;
        userCoords = [latitude, longitude];
        initMap(latitude, longitude);
      },
      err => {
        alert("GPS denied. Using default location.");
        userCoords = [0, 0];
        initMap(0, 0);
      }
    );

    // Process user queries on Enter key
    const userInput = document.getElementById('userInput');
    const globalSearchCheckbox = document.getElementById('globalSearch');
    userInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        processQuery();
      }
    });

    function processQuery() {
      const query = userInput.value.trim();
      if (!query) return;
      addMessage("User", query);
      userInput.value = "";
      handleSearch(query);
    }

    // Append messages to the chat window
    function addMessage(sender, text) {
      const messagesDiv = document.getElementById('messages');
      const msgElem = document.createElement('div');
      msgElem.innerHTML = `<strong>${sender}:</strong> ${text}`;
      messagesDiv.appendChild(msgElem);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Haversine formula to compute distance between two coordinates (in km)
    function haversineDistance(lat1, lon1, lat2, lon2) {
      function toRad(x) { return x * Math.PI / 180; }
      const R = 6371; // Earth's radius in km
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // Handle the search through Nominatim API
    function handleSearch(query) {
      if (!userCoords) {
        addMessage("AI", "Waiting for GPS...");
        return;
      }
      addMessage("AI", `Searching for "${query}"...`);
      const [lat, lon] = userCoords;
      
      let apiUrl;
      if (globalSearchCheckbox.checked) {
        apiUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5`;
      } else {
        const viewbox = `${lon-0.2},${lat+0.2},${lon+0.2},${lat-0.2}`;
        apiUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&viewbox=${viewbox}&bounded=1`;
      }
      
      fetch(apiUrl)
        .then(response => response.json())
        .then(results => {
          if (results.length === 0) {
            addMessage("AI", "Couldn't find that location.");
            return;
          }
          // Pick the closest result using the Haversine formula
          let bestResult = results[0];
          let bestDistance = haversineDistance(userCoords[0], userCoords[1], parseFloat(bestResult.lat), parseFloat(bestResult.lon));
          for (let i = 1; i < results.length; i++) {
            const currentResult = results[i];
            const d = haversineDistance(userCoords[0], userCoords[1], parseFloat(currentResult.lat), parseFloat(currentResult.lon));
            if (d < bestDistance) {
              bestDistance = d;
              bestResult = currentResult;
            }
          }
          const destLat = parseFloat(bestResult.lat);
          const destLon = parseFloat(bestResult.lon);
          addMessage("AI", `Found: ${bestResult.display_name}. Routing now...`);
          routeTo(destLat, destLon);
        })
        .catch(err => {
          console.error(err);
          addMessage("AI", "Error during search.");
        });
    }

    // Fetch route from OSRM and display route details in miles and time (converting 60+ minutes to hours)
    function routeTo(destLat, destLon) {
      const [startLat, startLon] = userCoords;
      const routeURL = `https://router.project-osrm.org/route/v1/walking/${startLon},${startLat};${destLon},${destLat}?overview=full&geometries=geojson`;
      
      fetch(routeURL)
        .then(res => res.json())
        .then(data => {
          if (data.code !== "Ok") {
            addMessage("AI", "Routing failed.");
            return;
          }
          const routeData = data.routes[0];
          const route = routeData.geometry;
          const distanceMeters = routeData.distance; // in meters
          // Convert distance to miles (1 mile = 1609.34 meters)
          const distanceMiles = (distanceMeters / 1609.34).toFixed(2);
          const durationSeconds = routeData.duration; // in seconds
          const totalMinutes = Math.round(durationSeconds / 60);
          
          // Convert minutes to hours and minutes if necessary
          let durationText;
          if (totalMinutes >= 60) {
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            durationText = `${hours} hour${hours > 1 ? 's' : ''}`;
            if (minutes > 0) {
              durationText += ` and ${minutes} minute${minutes > 1 ? 's' : ''}`;
            }
          } else {
            durationText = `${totalMinutes} minute${totalMinutes === 1 ? '' : 's'}`;
          }
          
          if (routeLayer) { map.removeLayer(routeLayer); }
          routeLayer = L.geoJSON(route).addTo(map);
          map.fitBounds(routeLayer.getBounds());
          addMessage("AI", `Route: ${distanceMiles} miles, approx. ${durationText}. Route displayed on map.`);
        })
        .catch(err => {
          console.error(err);
          addMessage("AI", "Error during routing.");
        });
    }
  </script>
</body>
</html>
